Ryan Blackburn
CS-210.8 Github Journal
Richard Foster
Southern New Hampshire University

Summarize the project and what problem it was solving.
  The project itself was to create a program which would give insight to a grocer about which items were being sold and at what frequency, so that the grocer
  could better stock his shelf to meet demands.
  The project required that we be able to read a file, utilize maps, and write to the screen using information that was written to another file.

What did you do particularly well?
  I think that I was efficient in using my map data for item counting, and also making the UI/UX intuitive and user friendly.  

Where could you enhance your code? How would these improvements make your code more efficient, secure, and so on?
  The code is very limited in what it can count, I would try to modularize it more so that it can read what is being counted and export this in a way that the user
  can control themselves. This would require a lot of secure coding in the input validation as well.

Which pieces of the code did you find most challenging to write, and how did you overcome this? What tools or resources are you adding to your support network?
  Making sure to clear the input in all instances was particularly tricky because I needed to find the correct methodology and ensure that I had it in all of the
  places that required it. After lots of bug running, snipping and trial and error, I sought out help from StackOverflow and found good solutions there. I will 
  also be adding resources like reddit communities to my support network.

What skills from this project will be particularly transferable to other projects or course work?
  Everything will transfer well, but going into particulars; programming basics, problem solving skills, and learning about Input/Output (I/O) handling will be 
  exceptionally helpful in my career field and projects.

How did you make this program maintainable, readable, and adaptable?
  The code is organized with clearly named functions that all have their own use, and are modulized inside the main code. This means that any item in the code can be
  changed or adapted to any other scenario / purpose without breaking the programs functionality, or without having to reinvent the wheel.
